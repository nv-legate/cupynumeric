{% set name = "cupynumeric" %}
{% if gpu_enabled == "true" %}
  {% set gpu_enabled_bool = true %}
  {% set cpu_gpu_tag='_gpu' %}
{% elif gpu_enabled == "false" %}
  {% set gpu_enabled_bool = false %}
  {% set cpu_gpu_tag='_cpu' %}
{% else %}
  {# We need to have a default value for the initial pass over the recipe #}
  {% set gpu_enabled_bool = false %}
  {% set cpu_gpu_tag='_cpu' %}
{% endif %}

{% if build_tests == "true" %}
  {% set build_tests_bool = true %}
{% elif build_tests == "false" %}
  {% set build_tests_bool = false %}
{% else %}
  {# We need to have a default value for the initial pass over the recipe #}
  {% set build_tests_bool = false %}
{% endif %}
{% if build_tests == "true" %}
  {% set build_tests_bool = true %}
{% elif build_tests == "false" %}
  {% set build_tests_bool = false %}
{% else %}
  {# We need to have a default value for the initial pass over the recipe #}
  {% set build_tests_bool = false %}
{% endif %}
## The placeholder version is strictly for making two-pass conda build process.
## It should not be used for any other purpose, and this is not a default version.
{% set placeholder_version = '0.0.0.dev' %}
{% set legate_cuda_version = environ.get('LEGATE_CUDA_VERSION') %}
{% if not legate_cuda_version %}
invalid_yaml_missing_cuda_version: LEGATE_CUDA_VERSION must be set
{% endif %}
{% set cuda_version='.'.join(legate_cuda_version.split('.')[:2]) %}
{% set cuda_major=cuda_version.split('.')[0]|int %}
{% set py_version=environ.get('CONDA_PY', '') %}
{% if build_number is defined %}
    {# do nothing if defined #}
{% else %}
    {% set build_number = environ.get('GIT_DESCRIBE_NUMBER', '0') %}
{% endif %}
{% if package_version is defined %}
    {% set version = package_version %}
    {% set legate_version = version %}
## The tag must be in one of the two formats (where N is a digit):
## vNN.NN.NN
## vNN.NN.NN.dev

## Note: default values are only given to make conda build work. They should not be necessary in principle.
{% elif 'dev' in environ.get('GIT_DESCRIBE_TAG', placeholder_version) %}
    {% set version = (environ.get('GIT_DESCRIBE_TAG', placeholder_version) ~ environ.get('GIT_DESCRIBE_NUMBER', '')).lstrip('v') %}
    {% set legate_version_default = (version.rsplit('.',1)[0] ~ ".dev" ~ "|>=" ~ version.rsplit('.',1)[0]) %}
    {% set legate_version = os.environ.get("LEGATE_VERSION", legate_version_default) %}
{% else %}
    {% set version = environ.get('GIT_DESCRIBE_TAG', placeholder_version).lstrip('v') %}
    {% set legate_version = os.environ.get("LEGATE_VERSION", version) %}
{% endif %}
{% set legate_buildstr = "_".join(["py" ~ py_version, "*" ~ cpu_gpu_tag.strip('_'), os.environ.get("LEGATE_BUILDSTR", "") ]) %}

package:
  name: {{ name|lower }}
  version: {{ version }}

source:
{% if package_tar is defined %}
  url: {{ package_tar }}
{% elif use_local_path is defined %}
  path: ../../
{% else %}
  git_url: ../../
{% endif %}

build:
  skip: true # [not linux]
  number: {{ build_number }}
  missing_dso_whitelist:
    -  '*libcuda.so*'
{% set upload_tag='_with_tests' if build_tests_bool else '' %}
{% if use_local_path is not defined %}
# use git hash
  string: "cuda{{ cuda_major }}_py{{ py_version }}{{ cpu_gpu_tag }}{{ upload_tag }}_{{ GIT_DESCRIBE_HASH }}_{{ PKG_BUILDNUM }}"
{% else %}
# do not use git hash
  string: "cuda{{ cuda_major }}_py{{ py_version }}{{ cpu_gpu_tag }}{{ upload_tag }}_{{ PKG_BUILDNUM }}"
{% endif %}
  script_env:
    - SCCACHE_BUCKET
    - SCCACHE_REGION
    - SCCACHE_IDLE_TIMEOUT
    - SCCACHE_S3_KEY_PREFIX
    - SCCACHE_S3_KEY_PREFIX
    - SCCACHE_S3_USE_SSL
    - SCCACHE_S3_NO_CREDENTIALS
    - AWS_ACCESS_KEY_ID
    - AWS_SECRET_ACCESS_KEY
    - AWS_SESSION_TOKEN
    - CMAKE_C_COMPILER_LAUNCHER
    - CMAKE_CUDA_COMPILER_LAUNCHER
    - CMAKE_CXX_COMPILER_LAUNCHER
{% if build_tests_bool %}
    - BUILD_TESTS=1
{% endif %}
{% if not gpu_enabled_bool %}
    - CPU_ONLY=1
  # The CPU-only packages having more track_features than the GPU builds helps
  # the solver to prefer the GPU builds when both are viable candidates.
  # ref: https://docs.conda.io/projects/conda-build/en/latest/resources/define-metadata.html#track-features
  track_features:
    - cpu_only
{% endif %}

  ignore_run_exports_from:
    # scikit-build should really be a part of the build env, but then it installs its own Python.  Conda build stacks
    # the build environment on the host environment, and the build python takes over causing paths havoc.  So, we put
    # scikit-build into the host env, but we ignore any exports it may bring.
    - scikit-build
    # We want to ignore any cuda related exports and we will redefine them ourselves with looser pins.
    - cuda-version
    - cuda-cudart
    - cuda-cudart-dev
    - libcublas
    - libcublas-dev
    - libcurand-dev
    - cuda-nvcc
    - cuda-cccl
    - libcusolver
    - libcusolver-dev
    - libcufile
    - libcufile-dev
    - libcufft
    - libcufft-dev

requirements:
  build:
    - make
    - ninja
    - cmake {{ cmake_version }}
    - {{ stdlib("c") }}
    - {{ compiler('c') }} =14
    - {{ compiler('cxx') }} =14
    # the nvcc requirement is necessary because it contains crt/host_config.h used by cuda runtime. This is a packaging bug that has been reported.
    - cuda-nvcc
    # cudart needed for CPU and GPU builds because of curand
    - cuda-cudart-dev
    - cuda-version ={{ cuda_version }}
    - libcurand-dev

  host:
    - python
    - scikit-build
    # Versions after v0.3.23 conflict with Realm's OpenMP runtime
    # see https://github.com/nv-legate/cupynumeric.internal/issues/342
    - openblas <=0.3.23 =*openmp*
    - legate ={{ legate_version }}=*{{ legate_buildstr }}
    - libhwloc
{% if gpu_enabled_bool %}
    - cuda-cccl
{% if cuda_major<13 %}
    # cutensor 2.3 drops support for Volta, so avoid that for our CUDA 12 builds
    - cutensor >=2.0,<2.3 =*_*
{% else %}
    # cutensor 2.3 is required for CUDA 13, so we have no choice but to drop
    # support for Volta on our CUDA 13 packages
    - cutensor >=2.0,<2.4 =*_*
{% endif %}
    - libcublas-dev
    - libcusolver-dev
    - libcufft-dev
    - libcurand-dev
    - libcufile-dev
    - cuda-version ={{ cuda_version }}
    - libcusolvermp-dev >=0.7
{% endif %}

  run:
    - cffi
    - numpy {{ numpy_version }}
    - opt_einsum >=3.3
    - scipy
    # Versions after v0.3.23 conflict with Realm's OpenMP runtime
    # see https://github.com/nv-legate/cupynumeric.internal/issues/342
    - openblas <=0.3.23 =*openmp*
{% if gpu_enabled_bool %}
    - __cuda
    - {{ pin_compatible('cuda-version', min_pin='x', max_pin='x') }}
    - {{ pin_compatible('cuda-cudart',  min_pin='x', max_pin='x') }}
    - {{ pin_compatible('libcublas',    min_pin='x', max_pin='x') }}
    - {{ pin_compatible('cuda-nvtx',    min_pin='x', max_pin='x') }}
    - {{ pin_compatible('libcusolver',  min_pin='x', max_pin='x') }}
    - {{ pin_compatible('libcufile',    min_pin='x', max_pin='x') }}
    - {{ pin_compatible('libcufft',    min_pin='x', max_pin='x') }}
    - nccl >=2.0,<3
    - cupy
    - libnvjitlink
{% endif %}

about:
  home: https://github.com/nv-legate/cupynumeric
  license: Apache-2.0
  license_file: LICENSE
  summary: 'NumPy and SciPy on Multi-Node Multi-GPU systems'
  description: |
    cuPyNumeric implements the NumPy API on top of the Legate framework,
    providing transparent accelerated computing that scales from a single CPU
    to a single GPU, and up to multi-node, multi-GPU systems.
  doc_url: https://github.com/nv-legate/cupynumeric
  dev_url: https://github.com/nv-legate/cupynumeric

extra:
  recipe-maintainers:
    - m3vaz
